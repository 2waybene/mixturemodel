firstDT <- getPopWIndex (dt.raw, index)
##  Save first population dt
FP_dt_primary <- firstDT + peaks[index]
dt.cleaned <- cleanFirstPop(peaks[index], firstDT, dt.raw)
#temp <- followUpClean (peaks[index], firstDT, dt.raw)
#plot(density(dt.cleaned))
#str(dt.cleaned)
##================================
##  Second round if ever needed
##================================
dt.raw  <- dt.cleaned
firstDT <- ""
get.gen <- ""
peaks   <- c()
index = 1
firstDT <- getPopWIndex (dt.raw, index)
#plot(density(firstDT))
get.den <- density(dt.raw)
peaks <- peak.quick (get.den$x, get.den$y)
peaks
##=========================================
##  Follow the same protocol, but just
##  carry out one more cleaning cycle
##  if there is any peaks less than 1.2
##===========================================
##Need to add the "cleaned back to population one"!!
dt.clean.return = list()
if (peaks[1] < 1.2)
{
#dt.another.clean <- cleanFirstPop(peaks[1], firstDT, dt.cleaned)
dt.clean.return <- followUpClean (peaks[1], firstDT, dt.raw)
#  plot(density(dt.another.clean))
#  dt.1pop.cleaned <- dt.another.clean
if (length(dt.clean.return$dtFiltered) > 0)
{
FP_dt_primary <- c(FP_dt_primary, dt.clean.return$dtFiltered)
}
dt.1pop.cleaned <- dt.clean.return$dtRetain
}else{
dt.1pop.cleaned <- dt.cleaned
}
FP_mean <- mean(FP_dt_primary)
FP_std <- sd(FP_dt_primary)
FP_count <- tol.num.of.dt  - length(dt.1pop.cleaned)
FP <- list ("FP_mean" = FP_mean, "FP_std" = FP_std, "FP_count" = FP_count)
cleanedSample <- c(cleanedSample, FP)
#cleanedSample
cleanedSample
1123-851
num.of.DI.left <- length(dt.1pop.cleaned)
num.of.DI.left
dt.clean.return$dtFiltered
FP_dt_primary
dt.clean.return
length(dt.clean.return$dtFiltered)
cleanedSample
dt.clean.return$dtFiltered)
dt.clean.return$dtFiltered
FP_dt_primary
i=6
#print (rawFiles[i])
fileName <- paste("myGit/mixturemodel/data/dt_01232014/OSCC/", rawFiles[i], sep ="")
f_IN <-  paste (root, fileName, sep ="")
nameSplit <- strsplit(f_IN, "/")[[1]]
sampleName <- nameSplit[length(nameSplit)]
sampleName <- sub(".csv", "", sampleName)
sampleName
cleanedSample <-  list("sample" = sampleName)
#cleanedSample
##============================
# read in the raw D.I. value
##============================
dt <- read.csv (f_IN)
## determine how many families are we dealing with
numOfFamily <-  1 # minimun one family
if (length(which(as.vector(dt$DNA_Index) > aneuThresh)) > 1)
{
numOfFamily = 3
}else if (length(which(as.vector(dt$DNA_Index) > mitoThresh)) > 1)
{
numOfFamily = 2
}
numOfFamily
##===================================================
##  removing the normal family
##  upto two round
##===================================================
dt.raw  <- ""
firstDT <- ""
get.gen <- ""
peaks   <- c()
dt.raw <- as.vector (dt$DNA_Index)
tol.num.of.dt <- length(dt.raw)
get.den <- density(dt.raw)
peaks <- peak.quick (get.den$x, get.den$y)
peaks
##===================================================
##  Determine where to start the first population
##  There could be more small peaks less than 1
##  Try to get the first one peaks > 1 but < 1.2
##====================================================
index = 1
length(which(peaks < 1))
if (peaks[length(which(peaks<1)) + 1] < 1.2)
{
index = length(which(peaks<1)) + 1
}else { index = length(which(peaks<1)) }
index
##============================================
##  clean starts here with first population
##============================================
firstDT <- getPopWIndex (dt.raw, index)
##  Save first population dt
FP_dt_primary <- firstDT + peaks[index]
dt.cleaned <- cleanFirstPop(peaks[index], firstDT, dt.raw)
#temp <- followUpClean (peaks[index], firstDT, dt.raw)
#plot(density(dt.cleaned))
#str(dt.cleaned)
##================================
##  Second round if ever needed
##================================
dt.raw  <- dt.cleaned
firstDT <- ""
get.gen <- ""
peaks   <- c()
index = 1
firstDT <- getPopWIndex (dt.raw, index)
#plot(density(firstDT))
get.den <- density(dt.raw)
peaks <- peak.quick (get.den$x, get.den$y)
peaks
##=========================================
##  Follow the same protocol, but just
##  carry out one more cleaning cycle
##  if there is any peaks less than 1.2
##===========================================
##Need to add the "cleaned back to population one"!!
dt.clean.return = list()
if (peaks[1] < 1.2)
{
#dt.another.clean <- cleanFirstPop(peaks[1], firstDT, dt.cleaned)
dt.clean.return <- followUpClean (peaks[1], firstDT, dt.raw)
#  plot(density(dt.another.clean))
#  dt.1pop.cleaned <- dt.another.clean
#if (length(dt.clean.return$dtFiltered) > 0) #
if (length(dt.clean.return$dtFiltered) > 1) #FIXME, there was a bug
{
FP_dt_primary <- c(FP_dt_primary, dt.clean.return$dtFiltered)
}
dt.1pop.cleaned <- dt.clean.return$dtRetain
}else{
dt.1pop.cleaned <- dt.cleaned
}
FP_mean <- mean(FP_dt_primary)
FP_std <- sd(FP_dt_primary)
FP_count <- tol.num.of.dt  - length(dt.1pop.cleaned)
FP <- list ("FP_mean" = FP_mean, "FP_std" = FP_std, "FP_count" = FP_count)
cleanedSample <- c(cleanedSample, FP)
cleanedSample
FP_dt_primary
num.of.DI.left <- length(dt.1pop.cleaned)
get.den <- density(dt.1pop.cleaned)
peaks <- peak.quick (get.den$x, get.den$y)
peaks
num.of.DI.left
plot(dt.1pop.cleaned)
plot(density(dt.1pop.cleaned))
index = 1
if (length(which(peaks < 1.5)) >=1 )
{
index <-which(peaks > 1.5)[1]
}
index
secondDT <- getPopWIndex (dt.1pop.cleaned, index)
dt.1pop.cleaned
index)
index
str(dt.1pop.cleaned)
str(secondDT)
SP_dt_primary <- (secondDT + peaks[index])
secondDT.cleaned <- cleanFirstPop(peaks[index],  secondDT, dt.1pop.cleaned)
#str(secondDT.cleaned)
secondDT.cleaned
peaks[index]
secondDT
dt.1pop.cleaned
stats(secondDT)
##==================================
get.den <- density(secondDT.cleaned)
peaks <- peak.quick (get.den$x, get.den$y)
peaks
##  Determine where to start the first population
index = 0
third_round = 0
if (length(peaks) > 1 &  length(which(peaks < 2)) >= 1)
{
index =  which(peaks < 2) [length(which(peaks < 2))]
}
third_round
index
if (index >=1)
{
secondDT.1 <- getPopWIndex (secondDT.cleaned, index)
#plot(density(secondDT.1))
#plot(density(secondDT.1 + peaks[index]))
secondDT.2.cleaned <- cleanFirstPop(peaks[index],  secondDT.1, secondDT.cleaned)
third_round = 1
#str(secondDT.2.cleaned)
#plot(density(secondDT.2.cleaned))
#stats (secondDT.2.cleaned)
}else{
secondDT.2.cleaned <- secondDT.cleaned
}
secondDT.2.cleaned
library(ks)
set.seed(1)
par(mfrow=c(2,1))
x<-rlnorm(100)
hist(x, col="red", freq=F)
lines(density(x))
y <- rkde(fhat=kde(x=x, h=hpi(x)), n=100, positive=TRUE)
hist(y, col="green", freq=F)
#	simulating DNA D.I. values
# Need to source ~/myGit/mixturemodel/Scripts/simDt_functions.R
#	normal population
library(Rlab)
##  OS specific directories:
mac.os  <- "/Users/li11/"
linux   <- "~/"
windows <- "X:/"
root <- mac.os
source (paste (root, "/myGit/mixturemodel/Scripts/simDt_functions.R", sep=""))
source (paste (root, "/myGit/mixturemodel/Scripts/simDt_functions.R", sep=""))
mean.norm <- c()
for (i in 1:20)
{
mean.norm[i] <- runif (1, 0.9,1.2)
}
mean.normalP <- mean.norm[sample(1:20,1)]
#	mitotic population
mean.mitotic <- c()
for (i in 1:20)
{
mean.mitotic[i] <- runif (1, 1.7,2.2)
}
mean.mitoticP <- mean.mitotic[sample(1:20,1)]
#	aneuploidy  population
mean.aneu <- 3.3
st.aneu <-3.5
n = 40
sample.aneu <- rnorm(n, mean = mean.aneu, sd = st.aneu)
sample.aneuP <- sample.aneu[sample.aneu >=0]
plot(density(sample.aneuP))
mean.aneuP <- mean(sample.aneuP)
sigmaA <- sd(sample.aneuP)
#  simulating DNA D.I. values
# Need to source ~/myGit/mixturemodel/Scripts/simDt_functions.R
#	normal population
library(Rlab)
##  OS specific directories:
mac.os  <- "/Users/li11/"
linux   <- "~/"
windows <- "X:/"
##=============================================
##  Read in data
##=============================================
#root <- windows
root <- mac.os
dt.dir <- paste (root, "/myGit/mixturemodel/cleanedData/OSCC", sep="")
files <- list.files (pattern=".rda")
files
files <- list.files (path = dt.dir, pattern=".rda")
files
i=1
load(paste(dt.dir, files[i], sep=""))
files[i]
dt.dir <- paste (root, "/myGit/mixturemodel/cleanedData/OSCC/", sep="")
files <- list.files (path = dt.dir, pattern=".rda")
files
aneuMax = 0;
aneuMin = 0;
i=1
load(paste(dt.dir, files[i], sep=""))
str()
ls()
str(cleanedSample)
str(cleanedSample$Aneuleft)
str(cleanedSample$AneuLeft)
max(cleanedSample$AneuLeft)
aneuMax = 0;
aneuMin = 2.3;
for (i in 1:length(files))
{
load(paste(dt.dir, files[i], sep=""))
if (aneuMax < max(cleanedSample$AneuLeft))
{
aneuMax = max(cleanedSample$AneuLeft))
}
}
i=1
load(paste(dt.dir, files[i], sep=""))
for (i in 1:length(files))
{
load(paste(dt.dir, files[i], sep=""))
if (aneuMax < max(cleanedSample$AneuLeft))
{
aneuMax = max(cleanedSample$AneuLeft)
}
}
for (i in 1:length(files))
{
load(paste(dt.dir, files[i], sep=""))
if (cleanedSample$AneuLeft) != "")
{
if (aneuMax < max(cleanedSample$AneuLeft))
{
aneuMax = max(cleanedSample$AneuLeft)
}
}
}
for (i in 1:length(files))
{
load(paste(dt.dir, files[i], sep=""))
if (cleanedSample$AneuLeft != "")
{
if (aneuMax < max(cleanedSample$AneuLeft))
{
aneuMax = max(cleanedSample$AneuLeft)
}
}
}
i
(cleanedSample$AneuLeft != "")
cleanedSample$AneuLeft
cleanedSample
cleanedSample$AneuLeft
length(cleanedSample$AneuLeft)
(length(cleanedSample$AneuLeft) != 0)
for (i in 1:length(files))
{
load(paste(dt.dir, files[i], sep=""))
if (length(cleanedSample$AneuLeft) != 0)
{
if (aneuMax < max(cleanedSample$AneuLeft))
{
aneuMax = max(cleanedSample$AneuLeft)
}
}
}
aneuMax
?do.call
do.call("complex", list(imag = 1:3))
library(golubEsets)
library(pvca)
data(Golub_Merge)
pct_threshold <- 0.6
batch.factors <- c("ALL.AML", "BM.PB", "Source")
pvcaObj <- pvcaBatchAssess (Golub_Merge, batch.factors, pct_threshold)
bp <- barplot(pvcaObj$dat,  xlab = "Effects",
ylab = "Weighted average proportion variance",
ylim= c(0,1.1),col = c("blue"), las=2,
main="PVCA estimation bar chart")
axis(1, at = bp, labels = pvcaObj$label, xlab = "Effects", cex.axis = 0.5, las=2)
values = pvcaObj$dat
new_values = round(values , 3)
text(bp,pvcaObj$dat,labels = new_values, pos=3, cex = 0.8)
license()
demo()
library(AppliedPredictiveModeling)
transparentTheme(trans = 0.4)
plotSubset <- data.frame(scale(mdrrDescr[, c("nC", "X4v")]))
xyplot(nC ~ X4v,
data = plotSubset,
groups = mdrrClass,
auto.key = list(columns = 2))
plot(1:5)
5908*12
#===============================================
##	Set up os paths
##==============================================
mac.os  <- "/Users/li11/"
linux   <- "~/"
windows <- "X:/"
root <- mac.os
library(caret)
sample.p <- rnorm(10)
sample.p
abs(sample.p)
sample.p <- sample (0:1, 100)
sample.p <- sample (c(0:1), 100)
sample.p <- sample (c(0:1), replace = TRUE, 100)
abs(sample.p)
pnorm(10)
?norm
?rnorm
runif(100, min=0, max=1)
plot(densith(runif(100, min=0, max=1)))
plot(density(runif(100, min=0, max=1)))
prob.c.100 <- runif(100, min=0, max=1)
prob.c.100*(log(prob.c.100))
-prob.c.100*(log(prob.c.100))
stats(-prob.c.100*(log(prob.c.100)))
plot(prob.c.100, -prob.c.100*(log(prob.c.100)))
plot(prob.c.100, (1-prob.c.100)*(log(prob.c.100)))
plot(prob.c.100, -(1-prob.c.100)*(log(prob.c.100)))
plot(prob.c.100, -1/((1-prob.c.100)*(log(prob.c.100))))
plot(prob.c.100, -1((1-prob.c.100)*(log(prob.c.100)))
)
plot(prob.c.100, -(1-prob.c.100)*(log(prob.c.100)))
##============================================
library(caret)
library(pROC)
library(Metrics)
#===========================
mac.os  <- "/Users/li11/"
linux   <- "~/"
windows <- "X:/"
#root <- windows
root <- mac.os
setwd(paste (root, "/myGit/mixturemodel/reconData/para2/", sep=""))
data <- read.table("recon_3classes_para3.txt", header=TRUE, sep = "\t")
str(data)
which(data$labe ==c)
which(data$labe ==c)
which(data$labe =="c")
data.c <- data[which(data$labe =="c"),]
boxplot(data.c)
boxplot(data.c[,-1])
?par
op <- par()
#sink ("log_param4.txt")
op <- par()
par (mfrow = c(1,3))
data.c <- data[which(data$labe =="c"),]
boxplot(data.c[,-1])
data.n <- data[which(data$labe =="n"),]
boxplot(data.n[,-1])
data.k <- data[which(data$labe =="k"),]
boxplot(data.k[,-1])
par(op)
op <- par()
par (mfrow = c(3,1))
data.c <- data[which(data$labe =="c"),]
boxplot(data.c[,-1])
data.n <- data[which(data$labe =="n"),]
boxplot(data.n[,-1])
data.k <- data[which(data$labe =="k"),]
boxplot(data.k[,-1])
par(op)
#sink ("log_param4.txt")
op <- par()
par (mfrow = c(1,3))
data.c <- data[which(data$labe =="c"),]
boxplot(data.c[,-1])
data.n <- data[which(data$labe =="n"),]
boxplot(data.n[,-1])
data.k <- data[which(data$labe =="k"),]
boxplot(data.k[,-1])
par(op)
str(data)
dim(data)
boxplot(data.c[,c(-1, -18)])
op <- par()
par (mfrow = c(1,3))
data.c <- data[which(data$labe =="c"),]
boxplot(data.c[,c(-1, -18)])
data.n <- data[which(data$labe =="n"),]
boxplot(data.n[,c(-1, -18)])
data.k <- data[which(data$labe =="k"),]
boxplot(data.k[,c(-1, -18)])
par(op)
##	data clea
var0 <- unlist(lapply(data, function(x) 0 == var(if (is.factor(x)) as.integer(x) else x)))
dataN0 <- data[,-which(var0)]
dim(dataN0)
var0
op <- par()
par (mfrow = c(1,3))
data.c <- data[which(data$labe =="c"),]
boxplot(data.c[,c(-1, -18)], main = "ExGCRn -- OSCC")
data.n <- data[which(data$labe =="n"),]
boxplot(data.n[,c(-1, -18)], main = "ExGCRn -- OSCC")
data.k <- data[which(data$labe =="k"),]
boxplot(data.k[,c(-1, -18)], main = "ExGCRn -- OSCC")
par(op)
op <- par()
par (mfrow = c(1,3))
data.c <- data[which(data$labe =="c"),]
boxplot(data.c[,c(-1, -18)], main = "ExGCRn -- OSCC")
data.n <- data[which(data$labe =="n"),]
boxplot(data.n[,c(-1, -18)], main = "ExGCRn -- Normal")
data.k <- data[which(data$labe =="k"),]
boxplot(data.k[,c(-1, -18)], main = "ExGCRn -- OLK")
par(op)
op <- par()
par (mfrow = c(1,3))
data.c <- data[which(data$labe =="c"),]
boxplot(data.c[,c(-1, -17, -18)], main = "ExGCRn -- OSCC")
data.n <- data[which(data$labe =="n"),]
boxplot(data.n[,c(-1, -17, -18)], main = "ExGCRn -- Normal")
data.k <- data[which(data$labe =="k"),]
boxplot(data.k[,c(-1, -17, -18)], main = "ExGCRn -- OLK")
par(op)
getwd()
plot(prob.c.100, -(1-prob.c.100)*(log(prob.c.100)))
plot(prob.c.100, -*(log(prob.c.100))
plot(prob.c.100, -(log(prob.c.100))
)
plot(prob.c.100, -(log(prob.c.100)))
plot(prob.c.100, -(1-prob.c.100)*(log(prob.c.100)))
plot(prob.c.100, -prob.c.100*(log(prob.c.100)))
plot(prob.c.100, -(prob.c.100^2)*(log(prob.c.100)))
