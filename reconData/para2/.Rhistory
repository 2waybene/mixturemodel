#	normal population
library(Rlab)
##  OS specific directories:
mac.os  <- "/Users/li11/"
linux   <- "~/"
windows <- "X:/"
root <- mac.os
source (paste (root, "/myGit/mixturemodel/Scripts/simDt_functions.R", sep=""))
source (paste (root, "/myGit/mixturemodel/Scripts/simDt_functions.R", sep=""))
mean.norm <- c()
for (i in 1:20)
{
mean.norm[i] <- runif (1, 0.9,1.2)
}
mean.normalP <- mean.norm[sample(1:20,1)]
#	mitotic population
mean.mitotic <- c()
for (i in 1:20)
{
mean.mitotic[i] <- runif (1, 1.7,2.2)
}
mean.mitoticP <- mean.mitotic[sample(1:20,1)]
#	aneuploidy  population
mean.aneu <- 3.3
st.aneu <-3.5
n = 40
sample.aneu <- rnorm(n, mean = mean.aneu, sd = st.aneu)
sample.aneuP <- sample.aneu[sample.aneu >=0]
plot(density(sample.aneuP))
mean.aneuP <- mean(sample.aneuP)
sigmaA <- sd(sample.aneuP)
#  simulating DNA D.I. values
# Need to source ~/myGit/mixturemodel/Scripts/simDt_functions.R
#	normal population
library(Rlab)
##  OS specific directories:
mac.os  <- "/Users/li11/"
linux   <- "~/"
windows <- "X:/"
##=============================================
##  Read in data
##=============================================
#root <- windows
root <- mac.os
dt.dir <- paste (root, "/myGit/mixturemodel/cleanedData/OSCC", sep="")
files <- list.files (pattern=".rda")
files
files <- list.files (path = dt.dir, pattern=".rda")
files
i=1
load(paste(dt.dir, files[i], sep=""))
files[i]
dt.dir <- paste (root, "/myGit/mixturemodel/cleanedData/OSCC/", sep="")
files <- list.files (path = dt.dir, pattern=".rda")
files
aneuMax = 0;
aneuMin = 0;
i=1
load(paste(dt.dir, files[i], sep=""))
str()
ls()
str(cleanedSample)
str(cleanedSample$Aneuleft)
str(cleanedSample$AneuLeft)
max(cleanedSample$AneuLeft)
aneuMax = 0;
aneuMin = 2.3;
for (i in 1:length(files))
{
load(paste(dt.dir, files[i], sep=""))
if (aneuMax < max(cleanedSample$AneuLeft))
{
aneuMax = max(cleanedSample$AneuLeft))
}
}
i=1
load(paste(dt.dir, files[i], sep=""))
for (i in 1:length(files))
{
load(paste(dt.dir, files[i], sep=""))
if (aneuMax < max(cleanedSample$AneuLeft))
{
aneuMax = max(cleanedSample$AneuLeft)
}
}
for (i in 1:length(files))
{
load(paste(dt.dir, files[i], sep=""))
if (cleanedSample$AneuLeft) != "")
{
if (aneuMax < max(cleanedSample$AneuLeft))
{
aneuMax = max(cleanedSample$AneuLeft)
}
}
}
for (i in 1:length(files))
{
load(paste(dt.dir, files[i], sep=""))
if (cleanedSample$AneuLeft != "")
{
if (aneuMax < max(cleanedSample$AneuLeft))
{
aneuMax = max(cleanedSample$AneuLeft)
}
}
}
i
(cleanedSample$AneuLeft != "")
cleanedSample$AneuLeft
cleanedSample
cleanedSample$AneuLeft
length(cleanedSample$AneuLeft)
(length(cleanedSample$AneuLeft) != 0)
for (i in 1:length(files))
{
load(paste(dt.dir, files[i], sep=""))
if (length(cleanedSample$AneuLeft) != 0)
{
if (aneuMax < max(cleanedSample$AneuLeft))
{
aneuMax = max(cleanedSample$AneuLeft)
}
}
}
aneuMax
?do.call
do.call("complex", list(imag = 1:3))
library(golubEsets)
library(pvca)
data(Golub_Merge)
pct_threshold <- 0.6
batch.factors <- c("ALL.AML", "BM.PB", "Source")
pvcaObj <- pvcaBatchAssess (Golub_Merge, batch.factors, pct_threshold)
bp <- barplot(pvcaObj$dat,  xlab = "Effects",
ylab = "Weighted average proportion variance",
ylim= c(0,1.1),col = c("blue"), las=2,
main="PVCA estimation bar chart")
axis(1, at = bp, labels = pvcaObj$label, xlab = "Effects", cex.axis = 0.5, las=2)
values = pvcaObj$dat
new_values = round(values , 3)
text(bp,pvcaObj$dat,labels = new_values, pos=3, cex = 0.8)
license()
demo()
library(AppliedPredictiveModeling)
transparentTheme(trans = 0.4)
plotSubset <- data.frame(scale(mdrrDescr[, c("nC", "X4v")]))
xyplot(nC ~ X4v,
data = plotSubset,
groups = mdrrClass,
auto.key = list(columns = 2))
plot(1:5)
5908*12
#===============================================
##	Set up os paths
##==============================================
mac.os  <- "/Users/li11/"
linux   <- "~/"
windows <- "X:/"
root <- mac.os
library(caret)
rawFiles
rawFiles <- list.files (paste(root, "myGit/mixturemodel/data/dt_01232014/OLK/",sep=""), pattern = "csv")
rawFiles
##  library and customized functions
library(Rlab)
##  OS specific directories:
mac.os  <- "/Users/li11/"
linux   <- "~/"
windows <- "X:/"
#root <- linux
#root <- windows
root <- mac.os
source (paste (root, "myGit/mixturemodel/Scripts/cleaningFuncs.R", sep = ""))
##=============================================
# Three criteria and can be modified
# aneuploidy: > 2.3c --> three populations
# mitotic:    > 1.7c --> two populations
# normal??
aneuThresh = 2.3
mitoThresh = 1.7
mitoMin    = 1.5
normThresh = 0.9 ## Not necessary at some point
normMax    = 1.2 ## For additional round of cleaning
##=============================================
##  Read in data
##=============================================
rawFiles <- list.files (paste(root, "myGit/mixturemodel/data/dt_01232014/OLK/",sep=""), pattern = "csv")
rawFiles
rawFile == "9559547.csv"
rawFiles == "9559547.csv"
which(rawFiles == "9559547.csv")
i = 78
fileName <- paste("myGit/mixturemodel/data/dt_01232014/OLK/", rawFiles[i], sep ="")
f_IN <-  paste (root, fileName, sep ="")
nameSplit <- strsplit(f_IN, "/")[[1]]
sampleName <- nameSplit[length(nameSplit)]
sampleName <- sub(".csv", "", sampleName)
sampleName
cleanedSample <-  list("sample" = sampleName)
cleanedSample
dt <- read.csv (f_IN)
## determine how many families are we dealing with
numOfFamily <-  1 # minimun one family
if (length(which(as.vector(dt$DNA_Index) > aneuThresh)) >= 1)
{
numOfFamily = 3
}else if (length(which(as.vector(dt$DNA_Index) > mitoThresh)) > 1)
{
numOfFamily = 2
}
numOfFamily
dt.raw  <- ""
firstDT <- ""
get.gen <- ""
peaks   <- c()
dt.raw <- as.vector (dt$DNA_Index)
tol.num.of.dt <- length(dt.raw)
get.den <- density(dt.raw)
peaks <- peak.quick (get.den$x, get.den$y)
peaks
index = 1
length(which(peaks < 1))
if (!(is.na((peaks[length(which(peaks<1)) + 1]))) & peaks[length(which(peaks<1)) + 1] < normMax )
{
index = length(which(peaks<1)) + 1
}else { index = length(which(peaks<1)) }
index
firstDT <- getPopWIndex (dt.raw, index)
##  Save first population dt
FP_dt_primary <- firstDT + peaks[index]
dt.cleaned <- cleanFirstPop(peaks[index], firstDT, dt.raw)
plot(density(dt.cleaned))
(length(firstDT) >= length(dt.raw) & numOfFamily <=2)
(length (get.den <- tryDensity (dt.cleaned)) >=1 )
FP_mean  <- mean(FP_dt_primary)
FP_std   <- sd(FP_dt_primary)
FP_count <- length(FP_dt_primary)
FP <- list ("FP_mean" = FP_mean, "FP_std" = FP_std, "FP_count" = FP_count)
cleanedSample <- c(cleanedSample, FP)
dt.1pop.cleaned <- dt.cleaned
SP_mean  <- mean(SP_dt_primary)
SP_std   <- sd(SP_dt_primary)
SP_count <- length(SP_dt_primary)
SP <- list ("SP_mean" = SP_mean, "SP_std" = SP_std, "SP_count" = SP_count)
cleanedSample <- c(cleanedSample, SP)
numOfFamily
peaks
length(which(peaks < 1))
if (!(is.na((peaks[length(which(peaks<1)) + 1]))) & peaks[length(which(peaks<1)) + 1] < normMax )
{
index = length(which(peaks<1)) + 1
}else { index = length(which(peaks<1)) }
index
(!(is.na((peaks[length(which(peaks<1)) + 1]))) & peaks[length(which(peaks<1)) + 1] < normMax )
fileName <- paste("myGit/mixturemodel/data/dt_01232014/OLK/", rawFiles[i], sep ="")
f_IN <-  paste (root, fileName, sep ="")
nameSplit <- strsplit(f_IN, "/")[[1]]
sampleName <- nameSplit[length(nameSplit)]
sampleName <- sub(".csv", "", sampleName)
sampleName
cleanedSample <-  list("sample" = sampleName)
cleanedSample
##============================
# read in the raw D.I. value
##============================
dt <- read.csv (f_IN)
## determine how many families are we dealing with
numOfFamily <-  1 # minimun one family
if (length(which(as.vector(dt$DNA_Index) > aneuThresh)) >= 1)
{
numOfFamily = 3
}else if (length(which(as.vector(dt$DNA_Index) > mitoThresh)) > 1)
{
numOfFamily = 2
}
numOfFamily
##===================================================
##  removing the normal family
##  upto two round
##===================================================
dt.raw  <- ""
firstDT <- ""
get.gen <- ""
peaks   <- c()
dt.raw <- as.vector (dt$DNA_Index)
tol.num.of.dt <- length(dt.raw)
get.den <- density(dt.raw)
peaks <- peak.quick (get.den$x, get.den$y)
peaks
##==========================================================
##  Determine where to start the first population
##  There could be more small peaks less than 1
##  Try to get the first one peaks > 1 but < 1.2 (normMax)
##==========================================================
index = 1
length(which(peaks < 1))
if (!(is.na((peaks[length(which(peaks<1)) + 1]))) & peaks[length(which(peaks<1)) + 1] < normMax )
{
index = length(which(peaks<1)) + 1
}else { index = length(which(peaks<1)) }
index
##============================================
##  clean starts here with first population
##============================================
firstDT <- getPopWIndex (dt.raw, index)
##  Save first population dt
FP_dt_primary <- firstDT + peaks[index]
dt.cleaned <- cleanFirstPop(peaks[index], firstDT, dt.raw)
if (length(firstDT) >= length(dt.raw) & numOfFamily <=2)
{
SP_dt_primary <- dt.raw[c(which(dt.raw > normMax))]
FP_mean  <- mean(FP_dt_primary)
FP_std   <- sd(FP_dt_primary)
FP_count <- length(FP_dt_primary)
FP <- list ("FP_mean" = FP_mean, "FP_std" = FP_std, "FP_count" = FP_count)
cleanedSample <- c(cleanedSample, FP)
}else{
##================================
##  Second round if ever needed
##================================
if (length (get.den <- tryDensity (dt.cleaned)) >=1 )
{
dt.raw  <- dt.cleaned
firstDT <- ""
get.gen <- ""
peaks   <- c()
index = 1
firstDT <- getPopWIndex (dt.raw, index) ##FIXME, yep breaks at sample 88!!!!
get.den <- density(dt.raw)
peaks <- peak.quick (get.den$x, get.den$y)
peaks
##=========================================
##  Follow the same protocol, but just
##  carry out one more cleaning cycle
##  if there is any peaks less than 1.2(normMax)
##===========================================
##Need to add the "cleaned back to population one"!!
dt.clean.return = list()
if (peaks[1] < normMax )
{
dt.clean.return <- followUpClean (peaks[1], firstDT, dt.raw)
if (length(dt.clean.return$dtFiltered) > 1) #FIXME, there was a bug
{
FP_dt_primary <- c(FP_dt_primary, dt.clean.return$dtFiltered)
}
dt.1pop.cleaned <- dt.clean.return$dtRetain
}else{
dt.1pop.cleaned <- dt.cleaned
}
##===================================
##  Storing the cleaning results
##===================================
FP_mean  <- mean(FP_dt_primary)
FP_std   <- sd(FP_dt_primary)
FP_count <- length(FP_dt_primary)
FP <- list ("FP_mean" = FP_mean, "FP_std" = FP_std, "FP_count" = FP_count)
cleanedSample <- c(cleanedSample, FP)
} else
{
FP_mean  <- mean(FP_dt_primary)
FP_std   <- sd(FP_dt_primary)
FP_count <- length(FP_dt_primary)
FP <- list ("FP_mean" = FP_mean, "FP_std" = FP_std, "FP_count" = FP_count)
cleanedSample <- c(cleanedSample, FP)
dt.1pop.cleaned <- dt.cleaned
}
}
##===========================================
##  No need to clean the second population
##===========================================
SP_mean  <- mean(SP_dt_primary)
SP_std   <- sd(SP_dt_primary)
SP_count <- length(SP_dt_primary)
SP <- list ("SP_mean" = SP_mean, "SP_std" = SP_std, "SP_count" = SP_count)
cleanedSample <- c(cleanedSample, SP)
aneup.pop <- ""
aneu <- list ("AneuLeft" = aneup.pop)
cleanedSample <- c(cleanedSample, aneu)
cleanedSample
parameters
##=====================================================
library(Rlab)
##  OS specific directories:
mac.os  <- "/Users/li11/"
linux   <- "~/"
windows <- "X:/"
#root <- windows
root <- mac.os
##==================================================================================
source (paste (root, "myGit/mixturemodel/Scripts/cleaningFuncs.R", sep = ""))
source (paste (root, "myGit/mixturemodel/Scripts/simDt_functions.R", sep = ""))
source (paste (root, "myGit/mixturemodel/Scripts/reconstrDtFunctions.R", sep = ""))
parameters <- para4()
parameters
dt.dir <- paste (root, "/myGit/mixturemodel/cleanedData/OLK/", sep="")
lab <- "k"
files <- list.files (path = dt.dir, pattern=".rda")
load(paste(dt.dir, "cleaned_9559503.rda", sep=""))
files
load(paste(dt.dir, "cleaned_9559547.rda", sep=""))
str(cleanedSample)
i
rawFiles
fileName <- paste("myGit/mixturemodel/data/dt_01232014/OLK/", rawFiles[i], sep ="")
fileName
f_IN <-  paste (root, fileName, sep ="")
nameSplit <- strsplit(f_IN, "/")[[1]]
sampleName <- nameSplit[length(nameSplit)]
sampleName <- sub(".csv", "", sampleName)
sampleName
cleanedSample <-  list("sample" = sampleName)
cleanedSample
dt <- read.csv (f_IN)
summary(dt)
## determine how many families are we dealing with
numOfFamily <-  1 # minimun one family
if (length(which(as.vector(dt$DNA_Index) > aneuThresh)) >= 1)
{
numOfFamily = 3
}else if (length(which(as.vector(dt$DNA_Index) > mitoThresh)) > 1)
{
numOfFamily = 2
}
numOfFamily
dt
head(dt)
summary(dt)
dt.raw <- as.vector (dt$DNA_Index)
tol.num.of.dt <- length(dt.raw)
tol.num.of.dt
get.den <- density(dt.raw)
peaks <- peak.quick (get.den$x, get.den$y)
peaks
plot(density(dt.raw))
is.na((peaks[length(which(peaks<1)) + 1])))
(is.na((peaks[length(which(peaks<1)) + 1]))
)
peaks[length(which(peaks<1)) + 1]
peaks[length(which(peaks<1)) + 1] < normMax
length(which(peaks<1)) + 1
index = 1
length(which(peaks < 1))
if (!(is.na((peaks[length(which(peaks<1)) + 1]))) & peaks[length(which(peaks<1)) + 1] < normMax )
{
index = length(which(peaks<1)) + 1
}else { index = length(which(peaks<1)) }
index
firstDT <- getPopWIndex (dt.raw, index)
plot(density(firstDT))
FP_dt_primary <- firstDT + peaks[index]
FP_dt_primary
peaks[index]
dt.cleaned <- cleanFirstPop(peaks[index], firstDT, dt.raw)
FP_dt_primary
plot(density(dt.cleaned))
(length (get.den <- tryDensity (dt.cleaned)) >=1 )
get.den
tryDensity (dt.cleaned)
(length (get.den <- tryDensity (dt.cleaned)) >=1 )
900*12
13000*.75
130000*.75
(gender <- factor(c("male", "female", "female"))
)
(gender <- factor(c("male", "female", "female")))
(gender <- factor(c("male", "female", "female")))
(gender <- factor(c("male", "female", "female")))
library(caret)
?train
root <- mac.os
#===============================================
#	Set up os paths
#==============================================
mac.os  <- "/Users/li11/"
linux   <- "~/"
windows <- "X:/"
root <- mac.os
setwd(paste (root, "/myGit/mixturemodel/reconData/para2/", sep=""))
reconFiles <- list.files (pattern = "recon_*")
reconFiles
i =1
parSet <- sub (".txt", "", sub ("recon_3classes_", "", reconFiles[i]))
comFigName <- paste ("Model_comparison_", parSet, ".png", sep = "")
title <- paste ("Model comparison with ", parSet,sep = "")
comFigName <- paste (root, "/myGit/mixturemodel/modeling/model_selection/", comFigName, sep="")
data <- read.table(reconFiles[i], header=TRUE, sep = "\t")
##	data cleaning
var0 <- unlist(lapply(data, function(x) 0 == var(if (is.factor(x)) as.integer(x) else x)))
dataN0 <- data[,-which(var0)]
#dataN0[,1] <- paste ("ID_", dataN0[,1], sep = "")
rownames(dataN0) <- paste ("ID_", dataN0[,1], sep = "")
dataN0[,1] <- null
##	Retain data ONLY with two classes
data.2.classes <- dataN0[-which (dataN0$label == "k"),]
data.k <- dataN0[which (dataN0$label == "k"),]
labels <- as.vector(data.2.classes$label)
data.2.classes <- data.2.classes[,-17]
data.2.classes <- cbind (data.2.classes, label=labels)
file2classes  <- data.2.classes
file.olk <- data.k
## create data partition
inTrainingSet <- createDataPartition(file2classes$label, p=.7, list=FALSE)
labelTrain <- file2classes[ inTrainingSet,]
labelTest <- file2classes[-inTrainingSet,]
nrow(labelTrain)
nrow(labelTest)
file2classes$label
length(file2classes$label)
data.k
str(data.k)
?pls
